


## **Путь к пониманию Celery.**

Паттерн: *producer/consumer - производитель/потребитель(воркер)*


У веб-приложений существует **2** типа операций:

 - request-time -выполняется в цикле запрос ответ (является главным показателем скорости работы)
 - фоновые задачи - то, что происходит после отправки ответа с сервера (вне цикла запрос-ответ).

Итак, предположим есть сервис со следующим функционалом:
 -   Отправка уведомлений о подтверждении или рассылка сообщений
 -   Ежедневное сканирование и скрапинг некоторой информации из разных источников и сохранение их
 -   Анализ данных
 -   Удаление ненужных ресурсов
 -   экспорт документов/фотографии в различных форматах


Если все эти операции выполняются в цикле запрос-ответ, то это печаль. Даже с ростом трафика отправка уведомлений о успешной регистрации становится критичным. Так что нужно выносить эти задачи в фоновую обработку. 	

> Наиболее распространенным шаблоном программирования, используемым для  этого сценария, является  **Producer-Consume**r паттерн(архитектура). Его смысл состоит в том, что один или несколько потоков _производят_ данные, и параллельно этому один или несколько потоков _потребляют_ их.

Основные понятия:

 - Задача(task)
 - Производитель/клиент(producers)
 - Потребитель(worker/consumer)
 - Посредник(brocker)
 - Очередь(queue)

**Как работает эта архитектура:**
-   Producers(производители, в данном случае клиенты) создают данные или задачи(имеется в виду, что в ходе выполнения request-time фукций,  производится инициализация тех задач, которые мы хотим отправить в фоновую обработку). В Django например это может быть любая функция, которая обрабатывает HttpRequest, внутри этой функции и будет вызов нашей задачи(task).
-   Задачи(tasks помещаются в очередь(queue), которая называется очередью задач(task queues).
-   Consumers(воркеры) несут ответственность за потребление данных или выполнение задач.

Разберем более подробно.
 Celery работает через сообщения, обычно используя посредника(**broker**) для взаимодействия между клиентами(**producers**) и работниками(**workers**). Чтобы инициировать задачу, клиент(**producer**) добавляет сообщение в очередь(**queue**), затем посредник(**broker**) передает это сообщение работнику(**worker**).
 Чтобы было проще это понять - вот схема:
 ![](https://2.bp.blogspot.com/-wKQ7PqXnzCo/Whw-722kzCI/AAAAAAAAAA4/9vysZxmKHVA_ex7V4gPVeJraqkcBroWRgCK4BGAYYCw/s640/celery_architecture.jpg)

Итак, чтобы начать работу, нам нужно выбрать инструмент, который будет обрабатывать передачу сообщений.
В официальной документации мы можем увидеть -

> The RabbitMQ and Redis broker transports are feature complete, but
> there’s also support for a myriad of other experimental solutions,
> including using SQLite for local development.

Итого: два самых популярных решения
 **1. RabbitMQ
 2. Redis**
 
 
 
## Пример (Redis)

Вынесем функцию отправки email в фоновую обработку.

 1. Устанавливаем `celery`
 2. Устанавливаем `redis`
 3.  Добавляем файл `celery.py`
 4. Определяем что будем выносить в фоновую обработку
 5.  Добавляем файл `tasks.py`
 6. Выносим определенную функцию в фоновую обработку
 7. Тестируем
